#' @title Format Species-Level Data for Hierarchical Stan Model
#'
#' @description
#' Prepares species-level binomial data for a hierarchical Bayesian model in Stan.
#' Converts a dataset with species and complex identifiers and counts into a list formatted for Stan input.
#' The model infers complex-level effects from species-level observations.
#'
#' @param data.req A data frame with species-level observations. Must include `speciesNb`, `complexNb`,
#'   and count columns `<varname>.num` (successes) and `<varname>.den` (trials).
#' @param varname Character. Name of the target variable (e.g., `"HBI"`, `"endophagy"`). Used to identify numerator and denominator columns.
#'
#' @return A named list with components:
#' \describe{
#'   \item{`N_species_obs`}{Number of species-level observations (rows).}
#'   \item{`N_species`}{Number of unique species.}
#'   \item{`N_complexes`}{Number of unique complexes.}
#'   \item{`r_species`}{Vector of observed counts of successes per observation.}
#'   \item{`N_species_`}{Vector of total counts (trials) per observation.}
#'   \item{`species_id`}{Integer vector mapping each observation to a species ID.}
#'   \item{`species_complex`}{Integer vector mapping each species to a complex ID.}
#' }
prepare_stan_data <- function(data.req, varname) {

  num_col <- paste0(varname, ".num")
  den_col <- paste0(varname, ".den")

  species_obs <- data.req |>
    dplyr::mutate(
      species_id = .data[["speciesNb"]],
      species_complex = .data[["complexNb"]]
    )

  r_species <- species_obs[[num_col]]
  N_species_ <- species_obs[[den_col]]
  species_id <- species_obs$species_id

  species_complex <- species_obs |>
    dplyr::group_by(species_id) |>
    dplyr::summarise(species_complex = dplyr::first(species_complex), .groups = "drop") |>
    dplyr::arrange(species_id) |>
    dplyr::pull(species_complex)

  list(
    N_species_obs = length(r_species),
    N_species = max(species_id),
    N_complexes = max(species_complex),
    r_species = r_species,
    N_species_ = N_species_,
    species_id = species_id,
    species_complex = species_complex
  )
}


#' Extract High Posterior Density (HPD) Samples from MCMC Output
#'
#' Extracts and filters posterior samples from an `rstan` MCMC object
#' to retain only those within the specified Highest Posterior Density (HPD) interval.
#' This function computes HPD intervals for each parameter and removes draws
#' falling outside these intervals across all chains.
#'
#' @param object An `rstan` model fit object (of class `stanfit`) containing posterior samples.
#' @param prob Numeric. The probability mass to include within the HPD interval.
#' Default is `0.99`, corresponding to the 99% HPD region.
#'
#' @return A list of MCMC chains (as `mcmc` objects) filtered to retain only
#' the samples lying within the HPD intervals for all parameters.
#' Chains are truncated to have equal length, corresponding to the smallest
#' number of retained samples among all chains.
#'
#' @details
#' The function first converts the Stan model output into a list of MCMC chains
#' using `rstan::As.mcmc.list()`. For each chain, it computes the HPD intervals
#' for every parameter via `coda::HPDinterval()`. Only iterations where all parameters
#' fall within their respective HPD bounds are kept.
#' To ensure consistency across chains, the function trims all filtered chains
#' to the same number of rows (equal to the smallest retained sample size).
#'
#' @export
extract_HPD_mcmc <- function(object, prob = 0.99) {

  mcmc_list <- rstan::As.mcmc.list(object)

  hpd_list <- lapply(mcmc_list, function(chain) {
    hpd <- coda::HPDinterval(chain, prob = prob)
    keep_rows <- rep(TRUE, nrow(chain))

    for (param in colnames(chain)) {
      lower <- hpd[param, "lower"]
      upper <- hpd[param, "upper"]
      keep_rows <- keep_rows & (chain[, param] >= lower & chain[, param] <= upper)
    }

    chain[keep_rows, , drop = FALSE]
  })

  hpd_list <- hpd_list[sapply(hpd_list, nrow) > 0]

  n_rows_min <- min(sapply(hpd_list, nrow))
  hpd_list <- lapply(hpd_list, function(df) df[seq_len(n_rows_min), , drop = FALSE])

  return(hpd_list)
}




#' Run Hierarchical Bayesian Model with rstan
#'
#' Loads, filters, and formats data, then compiles and runs a hierarchical Bayesian binomial model
#' using Stan. The model estimates species-level proportions within species complexes,
#' accounting for hierarchical structure and covariates such as region and year.
#'
#' @param data clean generated by creation_df()
#' @param iter Integer. Total number of MCMC iterations per chain (including warmup). Default is 2000.
#' @param chains Integer. Number of MCMC chains. Default is 4.
#' @param thinning Integer. Thinning interval for posterior samples. Default is 1.
#'
#' @return A named list containing:
#' \describe{
#'   \item{`fit`}{An `rstan` `stanfit` object with the fitted model and posterior samples.}
#'   \item{`species_complex`}{Data frame or vector linking species to complexes used in the model.}
#'   \item{`nice_varname`}{User-friendly variable name for labeling and plotting.}
#'   \item{`varname`}{The original variable name input.}
#'   \item{`iter`}{Number of iterations used in sampling.}
#'   \item{`warmup`}{Number of warmup (burn-in) iterations.}
#'   \item{`thinning`}{Thinning interval applied during sampling.}
#' }
#'
#' @details
#' The function calls `creation_df()` to filter and preprocess the data,
#' then prepares Stan-compatible data using `prepare_stan_data()`.
#' The Stan model file `"Hierarchical_Model.stan"` is loaded from the package directory,
#' compiled, and sampled with specified MCMC parameters.
#' Recommended control parameters `adapt_delta = 0.99` and `max_treedepth = 15` improve convergence.
#' Warmup is set to 20% of total iterations by default.
#'
#' @export
run_stan <- function(data = data,
                     iter = 3000,
                     chains = 4,
                     thinning = 1) {

  data_req <- data$data.req
  species_complex <- data$species_complex
  nice_varname <- data$nice_varname
  varname = data$varname

  stan_data <- prepare_stan_data(data_req, varname)

  warmup <- iter / 2

  if (varname != "resting_duration") {

    stan_file_path <- system.file("stan", "Hierarchical_Model.stan", package = "AnophelesBionomics")
    stan_model <- rstan::stan_model(file = stan_file_path)

    fit_rstan <- rstan::sampling(
      stan_model,
      data = stan_data,
      iter = iter,
      chains = chains,
      warmup = warmup,
      thin = thinning,
      control = list(adapt_delta = 0.99, max_treedepth = 15)
    )


  } else {
    stan_file_path <- system.file("stan", "Hierarchical_Model_for_resting.stan", package = "AnophelesBionomics")
    stan_model <- rstan::stan_model(file = stan_file_path)

    fit_rstan <- rstan::sampling(
      stan_model,
      data = stan_data,
      iter = iter,
      chains = chains,
      warmup = warmup,
      thin = thinning,
      control = list(adapt_delta = 0.99, max_treedepth = 15)
    )
  }

  fit <- extract_HPD_mcmc(fit_rstan)

  list(
    fit = fit,
    species_complex = species_complex,
    nice_varname = nice_varname,
    varname = varname,
    iter = iter,
    warmup = warmup,
    thinning = thinning
  )
}
